% !TeX encoding = windows-1250
\newtheorem{defn}{Definícia}[section]



\section{Teoretické základy}
V teoretickej èasti tejto práce si zadefinujeme jednotlivé pojmy, s ktorımi budeme ïalej pracova. Postupne si zadefinujeme SAT problém a sústavy rovníc s viacerımi pravımi stranami (MRHS).

\subsection{SAT}
\noindent Na lepšie vysvetlenie bude potrebné zavies si základné pojmy z vırokovej logiky. Definovanie pojmov je spracované pod¾a \cite{satdef} \cite{fikobp}.\newline
\newline
\noindent Formálna špecifikácia vırokovej logiky pozostáva z neprázdnej a neohranièenej mnoiny \(X\) zloenej z tzv. atomickıch vırokov a z mnoiny symbolov logickıch spojok \(\neg\) (negácia),  \(\wedge\) (konjunkcia), \(\vee\) (disjunkcia), \(\rightarrow\) (implikácia), \(\leftrightarrow\) (ekvivalencia) a pomocné symboly (zátvorky), ktoré definujú jazyk vırokovej logiky. Atomické vıroky budeme oznaèova vırokovımi premennımi  \((x{_1},x{_2},x{_3},...)\) . Atomické vıroky nadobúdajú pravdivostné hodnoty \(x{_i} \in \{ FALSE,TRUE \}\). Jazykom vırokovej logiky môeme definova tzv. vırokové formuly.

\begin{defn}	
	Formula vırokovej logiky je definovaná pomocou nasledujúcich syntaktickıch pravidiel:
	\begin{enumerate}
		\item Kadá vıroková premenná \(x{_i} \in X\) je vıroková formula.
		\item Ak \(A\) a \(B\) sú formule, tak \(\neg A, (A \wedge B), (A \vee B), (A \rightarrow B), (A \leftrightarrow B)\) sú tie formule.
		\item Kadá formula vzniká koneènım pouitím pravidiel (1.) a (2.).
	\end{enumerate}
\end{defn}
Formuly sú splnite¾né , ak dosadenie nejakıch hodôt za vırokové premenné a vyhodnotením logickıch spojok štandartnım spôsobom dostaneme pravdivostnú hodnotu \(TRUE\). Napr.následovnú formulu vyhodnotíme ako splnite¾nú, ak \(B=TRUE\).
\begin{equation}
(A\vee B)\wedge(\neg A \vee B)
\end{equation}
Pre naše potreby, si zadefinujeme ešte jeden špecialny tvar formúl vırokovej logiky tzv. konjuktívnu normálnu formu v skratke (CNF).
\begin{defn}
	\cite{satdef}
	Vıroková formula F je v konjuktívnej normálnej forme, ak má tvar konjunkcie (AND) koneèného poètu klauzúl \(f{_i}\), kde kadá klauzula je dizjunkciou (OR) literálov (atomické vıroky a ich negácie). Napríklad:
	\begin{equation}
	F=(x{_1} \vee \neg x{_2}) \wedge (x{_2} \vee x{_3}) \wedge (\neg x{_1} \vee x{_3})
	\end{equation}
	F je CNF formula s troma premennımi a troma klauzulami. Formulu \(F\) vyhodnotíme ako splnite¾nú, ak \(x{_1} = x{_2} = x{_3} = TRUE\).
\end{defn}

Klauzula, ktorá neobsahuje iadny literál, sa nazıva prázdna a vyhodnocuje sa ako \(FALSE.\)
Nastavenie logickıch premennıch na nejaké hodnoty oznaèíme pojmom interpretácia(formuly).

SAT je problém rozhodnutia, èi existuje interpretácia, ktorá spåòa danı booleovskı vıraz. Inımi slovami, pıtame sa, èi premenné daného booleovského vırazu, môu by nahradené hodnotami \(TRUE\) alebo \(FALSE\) takım spôsobom, e vıraz sa vyhodnotí ako \(TRUE.\) Ak je to tak, vıraz sa nazıva splnite¾nı. Na druhej strane, ak takéto priradenie neexistuje, vıraz je vyhodnotenı ako \(FALSE\) pre všetky moné priradenia premennıch, a vıraz je nesplnite¾nı. 

SAT problém je prvı známy NP-úplnı problém (dokázané Stephenom Cookom\cite{cook}). To znamená, e všetky problémy v triede zloitosti NP sú nanajvıš tak aké, ako SAT. Doposia¾, nie je známy algoritmus, ktorı efektívne rieši kadı SAT problém a všeobecne sa verí, e takıto algoritmus neexistuje.

\subsection{MRHS rovnice a sústavy}
V tejto podkapitole si zadefinujeme pojem rovnice s viacerımi pravımi stranami ako aj sústavu tıchto rovníc pod¾a èlánku \cite{mrhslingebra}. Všetky vıpoèty sú uskutoènené nad po¾om s dvoma prvkami (0 a 1) a oznaèením \(\mathbb{F} \). Všetky vektory \(\mathbb{F} \) sú riadkové vektory a sú oznaèené malım písmenom abecedy. Mnoiny sú znaèené ve¾kımi písmenami abecedy a matice tuènımi ve¾kımi písmenami. 

\begin{defn}
	\cite{mrhslingebra} Rovnicou s viacerımi pravımi stranami (MRHS) nad po¾om \(\mathbb{F} \) nazıvame vıraz tvaru
	\[x\mathbf{M} \in S,\]
	kde \(\mathbf{M}\) je matica s rozmermi \(n \times l\), kde n je poèet riadkov matice \(\mathbf{M}\) a l je poèet ståpcov, a \(S \subset    \mathbb{F}^l \) je mnoina \(l\)-bitovıch vektorov. Hovoríme, e \(x \in \mathbb{F}^n\) je riešením MRHS rovnice práve vtedy, keï \(x\mathbf{M} \in S\). 
\end{defn}

Sústavou rovníc s viacerımi pravımi stranami \(\mathcal{M}\) je mnoina \(m\) MRHS rovníc s rovnakou dimenziou \(n\) (rovnakı poèet riadkov). Formálne sa môe zapísa 
\[\mathcal{M} = \{x\mathbf{M}_i \in S_i|1\leq i\leq m \},\]
kde kadé \(\mathbf{M}_i\) je (\(n \times l_i\)) matica a \(S_i \subset \mathbb{F}^{l_i} \). Vektor \(x \in \mathbb{F}^n\) je riešením sústavy MRHS rovníc \(\mathcal{M}\), ak je tento vektor riešením pre všetky MRHS rovnice tejto sústavy.  

\textbf{Zdruená matica sústavy:} Sústave MRHS rovníc \(\mathcal{M} = \{x\mathbf{M}_i \in S_i\}\) môeme spoji všetky matice \(\mathbf{M_i}\), nako¾ko poèet ich riadkov je rovnakı. Vıslednú maticu oznaèujeme \(\mathbf{M}\) a nazıvame ju zdruenou maticou sústavy:
\[\mathbf{M} = [\mathbf{M_1}|\mathbf{M_2}|\cdots|\mathbf{M_m}]\]
Takisto budeme oznaèova mnoinu vektorov pravıch strán \(S_1 \times S_2 \times \cdots \times S_m\) ako \(S\). Nájdenie riešenia znamená nájdenie takého \(x \in \mathbb{F}^n\), pre ktoré platí \(x\mathbf{M} \in S\).\\
\textit{Pozn.:} Ståpce, ktoré patria \(\mathbf{M_i}\) nazıvame blok. V texte sa èasto budeme odvoláva na \(i\)-ty blok matice \(\mathbf{M}\).


\section{Algoritmy} \label{sec: algorithms}
V tejto kapitole si predstavíme všetky algoritmy, ktoré budeme vyuíva. Algoritmus na riešenie MRHS sústav, ktorı vyuíva MRHS solver je ukázanı v kapitole \ref{subsec: algMRHS}. Ostatné algoritmy sú algoritmy, ktoré sme implementovali do MRHS solvera a to prevod SAT problému na MRHS sústavu, heuristická optimalizácia poradia klauzúl v CNF formuli, Dual solver algoritmus na riešenie sústavy a transformácia MRHS sústavy na formát, ktorı vyaduje Dual solver algoritmus na vstupe.

\subsection{Algoritmus na riešenie MRHS sústavy} \label{subsec: algMRHS}
V tejto podkapitole si ukáeme algoritmus riešenia MRHS sústav, ktorı je implementovanı v MRHS solveri. Zápis tohoto algoritmu je prevzatı z \cite{jahobp} a \cite{mrhslingebra}


\begin{algorithm}[H]
	\caption{Uprav a vypoèítaj sústavu MRHS rovníc}
	\label{alg: solver} 
	\begin{algorithmic} 
		\REQUIRE MRHS sústava \(x\mathbf{M} \in S = S_1 \times S_2 \times \cdots \times S_m\)
		\ENSURE Mnoina \(X \subset \mathbb{F}^n\), pre ktorú platí  \(x\mathbf{M'} \in S\), \(\forall x \in X\), kde $\mathbf{M'}$ je upravená matica\\
		\COMMENT{ÚPRAVA ZDRUENEJ MATICE}
		\STATE Uprav maticu \(\mathbf{M}\) na redukovanı stupòovitı tvar cez riadkové úpravy.
		\STATE Vo všetkıch blokoch, ktoré obsahujú pivoty, vynuluj riadky, v ktorıch sa pivoty nachádzajú, cez såpcové úpravy.		
		\newline
		\COMMENT{REKURZÍVNE H¼ADANIE RIEŠENIA}
		\STATE \(X = \emptyset\), \(k = 1\), $x$ rozšírené o bity z $S_1[1]$
		\REQUIRE k, matica \(\mathbf{M}\), èiastoèné riešenie $x$, mnoina \(X\)
		\IF[m je poèet blokov]{k <= m}	 
		\FOR[n je poèet vektorov v mnoine  $S_k$]{j := 1, j<= n, j++}
		\IF{$x\mathbf{M_k}$ == $S_k[j]$}
		\IF{k == m}
		\STATE $X$ := $X$  \(\cup \{x\}\)
		\ENDIF
		\STATE rozšír $x$ o bity z $S_k[j]$
		\STATE $X$ := $X \cup rekurzia(k + 1, \mathbf{M}, x, X)$
		\ENDIF					
		\ENDFOR
		\ENDIF	
		\RETURN \(X\)
	\end{algorithmic}
\end{algorithm}

Tento algoritmus vráti len riešenia upravenej sústavy, a preto je nutné na základe vzorca \[x\mathbf{A^{-1}}\mathbf{A}\mathbf{M}\mathbf{B} \in S_M\mathbf{B},\] mono spätne vyjadri riešenie pôvodnej sústavy. Ak pre upravenú sústavu platí vzah $\mathbf{M'}=\mathbf{A}\mathbf{M}$, potom pre riešenia upravenej sústavy platí vzah $y=x\mathbf{A^{-1}}$. Keï osamostatníme $x$ dostaneme vzorec $x=y\mathbf{A}$, ktorım spätne vyrátame riešenia pôvodnej sústavy \cite{jahobp}. 
	
\subsection{Prevod SAT problému na MRHS} \label{subsubsec: satToMrhs}
 Kadá klauzula bude u nás predstavova jeden blok matice o ve¾kosti \(m \times n\), kde \(m\) je poèet literálov v klauzule a \(n\) je poèet všetkıch literálov. Poèet blokov hlavnej matice, je rovnı poètu klauzúl SAT problému. Prevod z formátu DIMACS na MRHS urobíme pomocou algoritmu v pseudokóde, ktorı je popísanı v algoritme \ref{alg: sat-to-mrhs-L}.

Pravé strany dostaneme tak, e si vypíšeme všetky moné riešenia pre danú klauzulu, ktorıch je \(2^{n}\), kde \(n\) oznaèuje poèet literálov v klauzule, a odstránime práve jedno riešenie, pre ktoré by klauzula nadobudla hodnotu \(FALSE\). Z toho dostávame e poèet pravıch strán je  \(2^{n}-1\).

\begin{algorithm}[H]
	\caption{Vytvorenie pravıch strán}
	\begin{algorithmic}
		\renewcommand{\algorithmicensure}{\textbf{Vıstup:}}
		\REQUIRE Matica \(\mathbf{S}\) \COMMENT{Matica \(\mathbf{S}\) z ALGORITMU \ref{alg: sat-to-mrhs-L}}
		\ENSURE Pole matíc \(\mathbb{P}\)
		\STATE Inicializuj \(\mathbb{P}\) a \(\mathbf{R}\)
		\FOR[s je velkos $\mathbf{S}$]{i := 0, i < s, i++}
		\STATE Vytvor pravdivostnú tabu¾ku pre N premennıch, kde N je ve¾kos \(\mathbf{S}[i]\) a ulo ju do \(\mathbf{R}\) \\
		\COMMENT{Vytvorenie zakázaného riešenia}
		\REQUIRE Pole \(K\) \COMMENT{\(K\) obsahuje \(i\)-ty riadok \(\mathbf{S}\)}
		\ENSURE Pole zakázané riešenie \(Z\)
		\STATE Inicializuj pole  \(Z\)
		\FOR[$m$ je ve¾kos $K$]{j := 0, j <  m, j++}
		\IF{\(K[j] > 0\)}
		\STATE Vlo hodnotu 0 do \(Z\)
		\ELSE
		\STATE Vlo hodnotu 1 do \(Z\)
		\ENDIF
		\ENDFOR
		\STATE Nájdi \(Z\) v \(\mathbf{R}\) a vyma ho. Vlo \(R\) do \(\mathbb{P}\)
		\ENDFOR
		\RETURN \(\mathbb{P}\)
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
	\caption{Vytvorenie hlavnej matice MRHS}
	\label{alg: sat-to-mrhs-L}
	\begin{algorithmic}
		\renewcommand{\algorithmicensure}{\textbf{Vıstup:}}
		\REQUIRE SAT problém vo formáte DIMACS 
		\ENSURE Matica \(\mathbf{S}\)
		\STATE Inicializuj premenné \(p\), \(k\),  \(count\), pole \(L\) a maticu  \(\mathbf{S}\)
		\STATE Naèítaj prvı riadok do \(L\)
		\WHILE{\(L[0]\) != \("p"\)}
		\STATE Naèítaj ïalší riadok
		\ENDWHILE
		\STATE Vyparsuj èíselné hodnoty z \(L\) a ulo ich do premennej \(p\) a \(k\) (poèet premenıch a poèet klauzúl).
		\WHILE{\(count\) == \(k\)}
		\STATE Inicializuj pole \(T\)
		\STATE Naèítaj riadok a ulo ho do \(T\)
		\STATE Vlo \(T\) do \(\mathbf{S}\)
		\STATE \(count++\) 
		\ENDWHILE
		\RETURN \(\mathbf{S}\)\\
		\COMMENT{Vytvorenie hlavnej matice}
		\REQUIRE Matica \(\mathbf{S}\), premenná \(p\)
		\ENSURE Pole matíc \(\mathbb{B}\) \COMMENT{Kadá matica reprezentuje jeden blok}
		\STATE Inicializuj pole matíc \(\mathbb{B}\)
		\STATE Inicializuj maticu \(\mathbf{H}\) a pole \(L\)
		\FOR[\(s\) je ve¾kos matice \(\mathbf{S}\) (poèet klauzúl)]{\(i := 0, i < s, i++\)}
		\FOR[\(p\) je poèet premennıch]{\(j := 0, j < p , j++\)}
		\FOR[\(r\) je ve¾kos \(\mathbf{S}{[i]}\) (poèet literálov v klauzule)]{\(k := 0, k < r, k++\)}
		\IF{\(\mathbf{S}[i][k]\) == \( j+1\) || \(\mathbf{S}[i][k]\) == \(-(j+1)\) }
		\STATE Vlo hodnotu 1 do \(L\)
		\ELSE
		\STATE Vlo hodnotu 0 do \(L\)
		\ENDIF
		\ENDFOR
		\STATE Vlo \(L\) do \(\mathbf{H}\) a vyèisti \(L\)
		\ENDFOR
		\STATE Vlo \(\mathbf{H}\) do \(\mathbb{B}\) a vyèisti \(\mathbf{H}\)
		\ENDFOR
		\RETURN \(\mathbb{B}\)
	\end{algorithmic}
\end{algorithm}

\subsection{Heuristická optimalizácia poradia klauzúl} \label{subsubsec: heuristicSAT}
V tejto kapitole si ukáeme heuristickı algoritmus na preusporiadanie klauzúl z práce \cite{fikobp}.


Majme bipartitnı graf \(G = (U, V, E)\) viï obrázok \ref{fig:Bipartitnı graf}:
\begin{figure}[H]
	\includegraphics[width=150px]{img/bipartite.png}
	\centering
	\caption{Bipartitnı graf \cite{bip}}
	\label{fig:Bipartitnı graf}
\end{figure}
kde \(|U|= n\) sú premenné, \(|V| = m\) sú klauzuly, \(E\) obsahuje hranu \((v_i, u_j)\), ak v \(i\)-tej klauzule \(i\) vystupuje \(j\)-ta premenná.\\
\\
Uvaujme, e klauzuly sú v nejakom poradí \(P\), èomu zodpovedajú èíslované vrcholy \({v_1, v_2, ..., v_m}\). Uvaujme postupnos indukovanıch podgrafov \((U^i, V^i, E^i)\), kde \(V^i = {v_1, v_2, ..., v_i}\), a \(U^i, E^i\), obsahujú všetky vrcholy a príslušné hrany spojené s \(V^i\).

Definujme postupnos \(d\), kde \(d_0 = 0\) a \(d_i = |U^i| - |U^{i-1}|\) (èie poèet vrcholov \(|U|\) pridanıch do podgrafu, ak pridáme \(v_i\)).\\

Úlohou je nájdenie poradia \(P\) vrcholov z \(V\) také, e postupnos \(d\) je minimálna v
lexikografickom poradí (t.j. \(d^P <= d^R\) ak existuje \(k\) také, e \(d^P_k <= d^R_k\) a pre všetky \(i < k: d^P_i = d^R_i\)).

Klauzuly v algoritme è. \ref{alg: heuristic-sat} sú reprezentované ako matica, kde kadı riadok matice reprezentuje jednu klauzulu. Na prvom indexe kadého riadku, je èíslo klauzuly a potom nasledujú premenné, ktoré obsahuje, ale iba v kladnej forme.

Premenné sú reprezentované tie v matici, kde kadı riadok matice reprezentuje jednu premennú. Na prvom indexe kadého riadku, je èíslo premennej a potom nasledujú èísla klauzúl, s ktorımi je daná premenná spojená.
\begin{algorithm}[H]
	\caption{Heuristická optimalizácia poradia klauzúl}
	\label{alg: heuristic-sat}
	\begin{algorithmic}
		\renewcommand{\algorithmicensure}{\textbf{Vıstup:}}
		\REQUIRE Matica \(\mathbf{S}\) \COMMENT{Matica \(\mathbf{S}\) z ALGORITMU \ref{alg: sat-to-mrhs-L}}
		\ENSURE Pole \(P\)
		\STATE Inicializuj maticu \(\mathbf{V}\)  a  \(\mathbf{U}\) 
		\FOR[s je ve¾kos $\mathbf{S}$]{i := 0, i < s, i++}
		\STATE Zoraï \(\mathbf{V}\) od najmenšieho stupòa
		\STATE Zoraï \(\mathbf{U}\) od najväèšieho stupòa
		\STATE Inicializuj \(MIN\) (klauzuly s minimálnym stupòom) a \(MAX\) (premenné s maximálnym stupòom)
		\STATE Nájdi všetky klauzuly v \(\mathbf{V}\) s minimálnym stupòom a vlo ich hodnotu na indexe 0 do \(MIN\)
		\IF[$m$ je ve¾kos $MIN$]{\(m\)  == 1}
		\STATE Vlo \(MIN\)[0] do \(P\)
		\ELSE
		\STATE Nájdi všetky premenné z \(\mathbf{U}\) s maximálnym stupòom, ktoré sú spojené s nejakou klauzulou z \(\mathbf{V}\) a vlo ich hodnotu na indexe 0 do \(MAX\)
		\IF[$n$ je ve¾kos $MAX$]{n == 1}
		\STATE Vlo hodnotu na indexe 0 z klauzule z \(V\) ktorá je spojená s premennou z \(\mathbf{U}\) do \(P\)
		\ELSE
		\STATE Vyber náhodne jeden index z \(MAX\) a vlo index klauzule, ktorá je spojená s touto premennou do po¾a \(P\)
		\ENDIF
		\ENDIF
		\STATE Odstráò vybranú klauzulu z \(\mathbf{V}\) a všetky premenné z \(\mathbf{U}\) s òou spojené.
		\ENDFOR
		\RETURN \(P\)
	\end{algorithmic}
\end{algorithm}

Úlohou algoritmu je vysklada novú sústavu, takım spôsobom, e kadá pridaná klauzula do sústavy pridá èo najmenej novıch premennıch. Inak povedané, sú preferované klauzuly, ktoré sa vyskytujú v najviac klauzulách CNF formuly.

\newpage
\subsection{Transformácia pre Dual space solver} \label{subsec: mrhstodual}
V tejto kapitole si ukáeme algoritmus transformácie MRHS sústavy pre algoritmus Dual solver. 

Ako prvé je potrebné vyrobi kontrolnú maticu  \(\mathbf{H}\) ku matici  \(\mathbf{M}\). Matica  \(\mathbf{M}\) má rozmery \(n \times l\), kde n je poèet riadkov matice a l je poèet ståpcov. Po upravení matice \(\mathbf{M}\) na redukovanı stupòovitı tvar, zoberieme \(n - l\) poslednıch såpcov a pridáme na spodnú èas matice maticu identity o ve¾kosti \(n \times n\). Tımto dostaneme kontrolnú maticu \(\mathbf{H}\), pre ktorú platí \(\mathbf{M}\mathbf{H} = 0 \). 

Ako druhé vytvoríme maticu \(\mathbf{S}\), ktorú vyrobíme nasledovne: 
\[
\mathbf{S} = 
\left(
\begin{array}{cccc}
S_1 & 0 & \dots & 0 \\
0 & S_2 & \dots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 01 & \dots & S_m  
\end{array}
\right)
\]
Matica  \(\mathbf{S}\) je blokovo diagonálna matica vytvorená z mnoín pravıch strán sústavy. Pre správnu pravú stranu \(s\) musí plati \(x\mathbf{M} = s\) a teda musí plati aj \(s \cdot \mathbf{H}^T = 0\). Vıstupom algoritmu bude matica \(\mathbf{V}\), pre ktorú platí \(\mathbf{V} = \mathbf{S} \cdot \mathbf{H}^T\) \cite{dualspacesolver}. Táto matica bude vstupom pre Dual solver algoritmus.

Nišie je spísanı pseudokód pre tento algoritmus.

\begin{algorithm}[H]
	\caption{Vytvorenie Dual solver vstupnej matice}
	\label{alg: mrhsdtodualsolver} 
	\begin{algorithmic} 
		\REQUIRE MRHS sústava \(x\mathbf{M} \in S = S_1 \times S_2 \times \cdots \times S_m\)
		\ENSURE Matica \(\mathbf{V}\)\\
		\STATE Uprav maticu \(\mathbf{M}\) na redukovanı stupòovitı tvar.
		\STATE Zober \(n - l\) poslednıch såpcov a pridaj k nim maticu identity o ve¾kosti \(n \times n\). Vıslednú maticu oznaèíme \(\mathbf{H}\)
		\STATE 	Vytvor blokovo diagonálnu maticu  \(\mathbf{S}\) z mnoiny pravıch strán sústavy.
		\STATE Vytvor maticu \(\mathbf{V}\), pre ktorú platí \(\mathbf{V} = \mathbf{S} \cdot \mathbf{H}^T\)
		\RETURN \(\mathbf{V}\)
	\end{algorithmic}
\end{algorithm}

\subsection{Dual space solution algoritmus} \label{subsec: dualspacesolutionalgorithm}
Dual space solution algoritmus, narozdiel od pôvodného algoritmu \ref{alg: solver} riešenia MRHS sústavy nie je závislı od poriadia rovníc vrámci sústavy. Princíp algoritmu je zaloenı na subset sum probléme \cite{subsetsum}, na nájdení urèitého súètu v danej mnoine. V našom prípade pôjde o nájdení súètu 0 v rámci ståpcu matice \(\mathbf{V}\). Z toho vyplıva predpoklad, e tento algoritmus bude silno závislı na hustote 1 v matici  \(\mathbf{V}\) a poradí ståpcov. Poradie ståpcov môe by zmenené pomocou lineárnej algebri na ståpcoch bez zmeny pôvodného riešenia MRHS sústavy.

Bliší popis algoritmu spolu s pseudokódom môete nájs v èlánku \cite{dualspacesolver}, ktorı vznikol ako produkt tohoto tímového projektu. Vısledky experimentov dual space solution algoritmu nájdete v kapitole o experimentoch. 

\section{Dokumentácia k programu}
V tejto kapitole si zhrnieme funkcionalitu, ktorá bola pridaná do MRHS solvera na základe SAT challenge špecifikácie a algoritmov.

\subsection{SAT challenge špecifikácia}
V tejto kapitole je struène popísaná SAT challenge špecifikácia. Zdroj: \cite{satcomp}. Nako¾ko tento tímovı projekt je viac zameranı na vedeckú èinnos, zo SAT challenge špecifikácie sme si privlastnili len input a output formáty, ktoré ma náš program spåòa. 

\subsubsection{DIMACS input formát} \label{subsubsec: DIMACS}
DIMACS CNF formát, je štandardnı vstupnı formát pre SAT solvery. Súbor DIMACS zaèína komentármi, ktoré sú na zaèiatku oznaèené malım písmenom c. Prvı riadok po komentári, je v tvare \(p\) \(cnf\) \(i\) \(j\). Premená \(i\) oznaèuje presnı poèet premennıch a \(j\) presnı poèet klauzúl obsiahnutıch v súbore, potom nasledujú klauzuly. Kadá klauzula môe obsahova nenulové èíslo z rozpätia \(-i\) a po \(i\). Záporné èísla oznaèujú negáciu. Kadı riadok, v ktorom je zapísaná klauzula, je ukonèenı nulou. Jeden riadok nemôe obsahova navzájom opaèné literály. Riadok, ktorı zaèína písmenom \(x\), oznaèuje klauzulu v \(XOR\) tvare.

\begin{figure}[H]
	\centering
	\begin{BVerbatim}
	c Súbor zaèína komentármi
	p cnf 5 3
	1 -5 4 0
	-1 5 3 4 0
	x 3 4 0
	\end{BVerbatim}
	\caption{Príklad DIMACS vstupného súboru.}
\end{figure}

V logickom tvare by vyzerala formula z obrázka è. 3 následovne:

\[
(x{_1} \vee \neg x{_5} \vee x{_4}) \wedge (\neg x{_1} \vee x{_5} \vee x{_3} \vee x{_4}) \wedge (\neg x{_3} \vee \neg x{_4}) \wedge (x{_3} \vee x{_4})
\]

\subsubsection{Output formát}
Do vıstupu programu boli pridané vypísi splnite¾nosti vstupnej k-SAT klauzule. V nišie zobrazenej tabu¾ke sú zapísané exit kódy programu spolu s vypísom splnite¾nosti, ktorı predstavujú. 

\begin{table}[H]
	\centering
	\caption{Exit kódy}
	\begin{tabular}{|l|l|}
		\hline
		exit(kód) & SAT ?         \\ \hline
		exit(10)  & SATISFIABLE   \\ \hline
		exit(20)  & UNSATISFIABLE \\ \hline
		exit(0)   & UNKNOWN       \\ \hline
	\end{tabular}
\end{table} 

\subsection{MRHS solver} \label{sec: solver}
Na riešenie sústav s viacerımi pravımi stranami budeme pouíva program MRHS solver, ktorı vyvinul prof. Ing. Pavol Zajac, phD. Algoritmus \ref{alg: solver}, ktorı sme si predstavili v kapitole \ref{sec: algorithms} sa vyuíva práve v tomto programe na riešenie sústavy. 


Jednım z naších cielov bolo implementova aby vstupom algoritmu bol súbor formátu DIMACS ukázanı v kapitole \ref{subsubsec: DIMACS}. Následne aby sme mohli vyuíva optimalizaènı algoritmus z kapitoly \ref{subsubsec: heuristicSAT}, museli sme rozšíri MRHS solver o nové interface-i aby vedel pracova s CNF štruktúrami. Nako¾ko pôvodnı algoritmus \ref{alg: solver} riešenia sústavy stále pracuje so štruktúrami podobnımi s tımi spomenutımi v nasledujúcej kapitole o vstupnom formáte súborov pre MRHS solver, bolo nutné implementova algoritmus z kapitoly \ref{subsubsec: satToMrhs} aby sme k-SAT problém transformovali do MRHS sústavy. Následne takto transformovanı k-SAT problém je moné rieši MRHS solverom. 

V prípade, e máme MRHS sústavu v takto pôvodnom tvare, je moné pomocou algoritmu \ref{alg: mrhsdtodualsolver} transformova sústavu do matice \(\mathbf{V}\), ktorú vie vypoèíta algoritmus Dual space solver spomenutı v kapitole \ref{subsec: dualspacesolutionalgorithm} a podrobnejšie spísanı v èlánku  \cite{dualspacesolver}.


\subsection{Nová funkcionalita}
Nako¾ko MRHS solver je konzolová aplikácia, ktorej úèelom je vypoèíta sústavu rovníc s viacerımi pravımi stranami, tak celı beh programu je nastavenı pri spustení programu pomocou prepínaèov. Do programu boli pridané nasledovné prepínaèe: 

\begin{itemize}
	\item -t  = poèet sekúnd, po ktorıch sa má program vypnú a vráti exit kód UNKNOWN (0)
	\item -i = s hodnotou 1 zapne optimalizáciu vstupnej k-SAT formule (algoritmus \ref{alg: heuristic-sat}), defaultne je zadaná hodnota nula (bez optimalizácie)
	\item -a = typ solvera. Pre hodnotu 0 je algoritmus riešenia sústavy nastavenı na pôvodnı algoritmus riešenia (alg. \ref{alg: solver}). Pre hodnotu 2 je pouitı dual space solution algoritmus (alg. \ref{subsec: dualspacesolutionalgorithm}). Pre hodnotu 3 sa sústava vypoèíta oboma algoritmami.
\end{itemize}

Prepínaèe programu sú stavané na jednoduchú prácu so solverom poèas experimentov. 
\section{Experimentálna èas}
Naším cie¾om bolo systematicky porovna dobu riešenia náhodne generovanej sústavy k-SAT klauzule s dobou riešenia tejto sústavy po úprave algoritmom \ref{alg: heuristic-sat}. Na riešenie sústav sme pouili MRHS solver s algoritmami na riešenie sústavy \ref{alg: solver} a dual space solution z kapitoly \ref{subsec: dualspacesolutionalgorithm}. Na generovanie k-SAT formúl sme vyuili program Cnfgen \cite{cnfgen}. 

\subsection{Testovacia platforma}
Všetky vıpoèty boli robené na jednom zariadení pre zaistenie èo najmenších odchılok. Parametre poèítaèa, na ktorom boli uskutoènené vıpoèty, sú:
\begin{itemize}
	\item Procesor: Intel core i5 - 8600K, 3.6GHz
	\item RAM: 16GB
\end{itemize} 
 Vıpoèty prebiehali na jednom jadre procesora.
 
 
 \subsection{Metodika experimentov}\label{subsec: metodikaEXP}
Skúmali sme náhodné k-Sat problémy. Pre tieto testy sme si zvolili \(k = {3, 4}\) a menili sme rôzne faktory a sledovali ako vplıvajú na vıstup. Sledovanou premennou bude èas [s], za ktorı dokáu algoritmy na riešenie sústav nájs všetky riešenia problému. Pre kadú sadu testov, sa vygenerovali problémy s následovnımi faktormi:

\textbf{Fixnı pomer \(m/n\)}

Tento pomer, sme volili rôzny pre jednotlivé \(k\) pod¾a štúdií \cite{Threshold}\cite{Threshold2}, tak aby sme boli v oblasti tzv. najaších problémov. 

\textbf{Pevne dané \(n\) a premenlivé \(m\)}

Pri tomto teste sme si nastavili spodnú hranicu tak, aby bola pravdepodobnos splnite¾nosti cca. 90\% a hornú hranicu sme nastavili tak, aby bola pravdepodobnos splnite¾nosti 0\% pod¾a vzahu \(m/n = 2^{k} \log 2 - \frac{\log 2}{2}\) (vzah prebratı z \cite{unsatisfiable}). 
\\
Následne sme na tieto problémy aplikovali naše algoritmy samostatne, ale aj v kombinácii. Aplikovali sa naslednovné algoritmy:

\textbf{Experimenty s pôvodnım algoritmom riešenia sústavy}

Vygenerované k-SAT problémy boli transformované na MRHS sústavu a následne riešené algoritmom \ref{alg: solver}.

\textbf{Experimenty s dual space solution algoritmom}
Vygenerované k-SAT problémy po transformácií na MRHS sústavu boli transformované na novú reprezentáciu problému spomenutú v kapitole \ref{subsec: mrhstodual} a následne riešenie pomocou algoritmu z kapitoly \ref{subsec: dualspacesolutionalgorithm}.

\textbf{Experimenty s heuristickou optimalizáciou}
Na vygenerované k-sat problémy, sme aplikovali nami implementovanú heuristickú optimalizáciu poradia klauzúl. Následne sme porovnávali èasy, potrebné na nájdenie všetkıch riešení s vyuitím pôvodného algoritmu riešenia sústavy a dual space solution algoritmom.


\subsection{Vyhodnotenie experimentov}
Všetky grafy v tejto kapitole sú zobrazené v logarimickej mierke na y-osi.
\subsubsection{3-SAT pevnı pomer \(m/n\)}
V tomto experimente sme skúmali vplyv zvyšujúceho sa poètu premennıch \(n\) v 3-sat formule pri pomere  \(m/n = 4.2\). 

\begin{figure}[H]
	\includegraphics[width=\textwidth]{img/3satPevnyPomer.png}
	\centering
	\caption{Experiment 1: 3-SAT pevnı pomer \(m/n\)}
	\label{exp: 3-sat-fixed}
\end{figure}

Z vyššie zobrazeného obrázku \ref{exp: 3-sat-fixed} mono vidie, e dual space solution algoritmus bez pre-optimalizácie exponenciálne rıchlejšie rastie v porovnaní s ostatnımi spôsobmi riešenia. Najlepší èas sme dosiahli v prípade pouitia pôvodného algoritmu a pre-optimalizácie 3-sat formule.

\subsubsection{3-SAT premenlivı pomer}
V tomto experimente sme skúmali vplyv zvyšujúceho sa pomeru \(m/n\) na dobu riešenia sústavy.

\begin{figure}[H]
\includegraphics[width=\textwidth]{img/3satPremenlivyPomer.png}
\centering
\caption{Experiment 2: 3-SAT premenlivı pomer}
\label{exp: 3-sat-variable}
\end{figure}

V prípade zvyšujúceho sa pomeru \(m/n\) mono zvyššie zobrazeného grafu vidie, e pôvodnı algoritmus riešenia s heuristickou optimalizáciou klauzúl sa od pomeru 2 zaèal zlepšova. Ostatné algoritmy exponenciálne rástli so zvyšujúcim sa pomerom.

\subsubsection{4-SAT pevnı pomer \(m/n\)}
V tomto experimente sme skúmali vplyv zvyšujúceho sa poètu premennıch \(n\) v 4-sat formule pri pomere  \(m/n = 9.7\). 
\begin{figure}[H]
	\includegraphics[width=\textwidth]{img/4satPevnyPomer.png}
	\centering
	\caption{Experiment 3: 4-SAT pevnı pomer \(m/n\)}
	\label{exp: 4-sat-fixed}
\end{figure}

Z obrázka mono jasne vidie prevahu v èase riešenia medzi pôvodnım algoritom riešenia sústavy bez pouitia optimalizácie a s pouitím optimalizácie. V prípade pouitia optimalizácie je zrıchlenie nájdenia riešenia nieko¾ko násobné. Z tohoto experimentu sa dá utvrdi predpoklad, e dual space solution algoritmus je závislı od lineárnej algebry a nie od poradia rovníc sústavy. Z grafu mono vidie, e rozdie¾ medzi optimalizovanou sústavou a sústavou bez optimalizácie je nepatrnı. 
\subsubsection{4-SAT premenlivı pomer}
V tomto experimente sme skúmali vplyv zvyšujúceho sa pomeru \(m/n\) na dobu riešenia sústavy.
\begin{figure}[H]
	\includegraphics[width=\textwidth]{img/4satPremenlivyPomer.png}
	\centering
	\caption{Experiment 4: 4-SAT premenlivı pomer}
	\label{exp: 4-sat-variable}
\end{figure}

Z grafu mono vidie, e doba riešenia sústavy za pouitia pôvodného algoritmu riešenia sústavy spolu s optimalizáciou sa v prípade, zvyšujúceho pomeru zlepšuje. V prípade nepouitia optimalizácie sa zdá by doba riešenia sústavy s pôvodnım algoritmom riešenia konštantná. 

Heuristická optimalizácia dokáe nieko¾ko násobne zlepši dobu riešenia sústavy v prípade pouitia dual space solution algoritmu, ale v porovnaní s pôvodnım algoritmom je stále priestor na zlepšenie.