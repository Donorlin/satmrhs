% !TeX encoding = windows-1250
\newtheorem{defn}{Definícia}[section]

\section{Ponuka}
\subsection{Tím}
Náš tím sa skladá z 3 èlenov. Ide o troch programátorov, ktorí študujú na FEI STU odbor aplikovaná informatika. Všetci traja sme v minulosti spolupracovali na našich bakalárskych prácach s prof. Zajacom (zadávate¾ tímového projektu) na témach úzko súvisiacich s témou tímového projektu. Jednotlivı èlenovia tímu:

\textbf{Alena Bednáriková} - programátorka. Témou jej bakalárskej práce bolo riešenie MQ problému. Jej hlavnım prínosom pre tím je jej logické uvaovanie.

\textbf{Daniel Jahodka} - programátor. Obsahom jeho bakalárskej práce boli sústavy MRHS rovníc a ich úprava pomocou heuristickıch algoritmov. Jeho hlavnım prínosom pre tím je riešenie problémov a návrh ich riešeni, prevane tıch programátorskıch.

\textbf{Fikrim Kabashi} - programátor so zameraním na C, C++ jazyky. Obsahom jeho bakalárskej práce bol práve SAT problém a MRHS rovnice. Implementoval algoritmus na heuristickú optimalizáciu poradia jednotlivıch klauzúl v SAT formule. Práve tento algoritmus je jeden z tıch, ktoré budeme implementova do MRHS solvera. 

\subsection{Motivácia}
Hlavnou motiváciou, preèo chceme rieši práve tento tímovı projekt je fakt, e obsah tohoto tímového projektu priamo nadväzuje na naše bakalárske práce a máme s danou témou a problematikou u nejaké skúsenosti. V našom prípade nebudeme musie sa venova úplnım základom oh¾adom tém MRHS sústav a SAT problému, ale budeme môc sa hneï venova novej problematike a prípadej implementácií novıch algoritmov, èi u na riešenie MRHS sústav/SAT problému alebo ich úprav. 

\subsection{Hrubı návrh a plán projektu}
Nako¾ko ide o vedecky zameranı projekt, tak hlavnım plánom projektu je implementova resp. doimplementova nové algoritmy do MRHS solveru a následne vyhodnoti dobu riešenie MRHS sústavy. Medzi plánované veci, ktoré sa budú implementova do solvera sú:

\begin{itemize}
	\item transformácia SAT do MRHS
	\item heuristická optimalizácia poradia SAT klauzúl
	\item SAT challenge formality
	\item Dual solver
\end{itemize}

\subsection{Predpokladané zdroje}
Najhlavnejším zdrojom, ktorı budeme potrebova pre urıchlenie vıpoètov je prístup k školskému klastru \url{https://www.hpc.stuba.sk}. Vïaka klastru, by sme dokázali paralelne spúša vıpoèty a úrıchli tak získanie vısledkov a ich následné vyhodnotie.

\subsection{Rozvrh}
Všetci traja èlenovia máme rovnakı rozvrh. So zadávate¾om tímového projektu máme konzultaènú hodinu dohodnutú na kadu stredu semestra o 14 hodine.

\section{Ciele riešenia}
Vedúci tímového projektu prof. Pavol Zajac vyvinul softvér MRHS solver na riešenie sústav s viacerımi pravımi stranami. Ide o program napísanı v jazyku C. Algoritmus riešenia sústavy je popísanı v kapitole o algoritmoch. Cie¾om projektu je rozšíri tento program o novı algoritmus riešenia sústav tzv. Dual solver, o heuristickú optimalizáciu poradia klauzúl CNF formuli, o prevod CNF formuli do MRHS sústavy a o funkcionalitu v podobe špecifickıch vıstupov a exit kódov programu, ktoré vyaduje SAT challenge pre zúèastnenie. 

Po implementovaní vyššie spomenutıch algoritmov bude našou úlohou pripravi experimenty na porovnanie dåky èasu riešenia sústavy za pouitia pôvodného algoritmu MRHS solveru a za pouitia Dual solver algoritmu. Vstupom algoritmov bude náhodne vygenerovaná 3-SAT (3-CNF) formula resp. 3-SAT formula upravená heuristickım algoritmom na optimalizáciu poradia klauzúl

\section{Teoretické základy}
V teoretickej èasti tejto práce si zadefinujeme jednotlivé pojmy, s ktorımi budeme ïalej pracova. Postupne si zadefinujeme SAT problém a sústavy rovníc s viacerımi pravımi stranami (MRHS).

\subsection{SAT}
\noindent Na lepšie vysvetlenie bude potrebné zavies si základné pojmy z vırokovej logiky. Definovanie pojmov je spracované pod¾a \cite{satdef} \cite{fikobp}.\newline
\newline
\noindent Formálna špecifikácia vırokovej logiky pozostáva z neprázdnej a neohranièenej mnoiny \(X\) zloenej z tzv. atomickıch vırokov a z mnoiny symbolov logickıch spojok \(\neg\) (negácia),  \(\wedge\) (konjunkcia), \(\vee\) (disjunkcia), \(\rightarrow\) (implikácia), \(\leftrightarrow\) (ekvivalencia) a pomocné symboly (zátvorky), ktoré definujú jazyk vırokovej logiky. Atomické vıroky budeme oznaèova vırokovımi premennımi  \((x{_1},x{_2},x{_3},...)\) . Atomické vıroky nadobúdajú pravdivostné hodnoty \(x{_i} \in \{ FALSE,TRUE \}\). Jazykom vırokovej logiky môeme definova tzv. vırokové formuly.

\begin{defn}	
	Formula vırokovej logiky je definovaná pomocou nasledujúcich syntaktickıch pravidiel:
	\begin{enumerate}
		\item Kadá vıroková premenná \(x{_i} \in X\) je vıroková formula.
		\item Ak \(A\) a \(B\) sú formule, tak \(\neg A, (A \wedge B), (A \vee B), (A \rightarrow B), (A \leftrightarrow B)\) sú tie formule.
		\item Kadá formula vzniká koneènım pouitím pravidiel (1.) a (2.).
	\end{enumerate}
\end{defn}
Formuly sú splnite¾né , ak dosadenie nejakıch hodôt za vırokové premenné a vyhodnotením logickıch spojok štandartnım spôsobom dostaneme pravdivostnú hodnotu \(TRUE\). Napr.následovnú formulu vyhodnotíme ako splnite¾nú, ak \(B=TRUE\).
\begin{equation}
(A\vee B)\wedge(\neg A \vee B)
\end{equation}
Pre naše potreby, si zadefinujeme ešte jeden špecialny tvar formúl vırokovej logiky tzv. konjuktívnu normálnu formu v skratke (CNF).
\begin{defn}
	\cite{satdef}
	Vıroková formula F je v konjuktívnej normálnej forme, ak má tvar konjunkcie (AND) koneèného poètu klauzúl \(f{_i}\), kde kadá klauzula je dizjunkciou (OR) literálov (atomické vıroky a ich negácie). Napríklad:
	\begin{equation}
	F=(x{_1} \vee \neg x{_2}) \wedge (x{_2} \vee x{_3}) \wedge (\neg x{_1} \vee x{_3})
	\end{equation}
	F je CNF formula s troma premennımi a troma klauzulami. Formulu \(F\) vyhodnotíme ako splnite¾nú, ak \(x{_1} = x{_2} = x{_3} = TRUE\).
\end{defn}

Klauzula, ktorá neobsahuje iadny literál, sa nazıva prázdna a vyhodnocuje sa ako \(FALSE.\)
\newline

Nastavenie logickıch premennıch na nejaké hodnoty oznaèíme pojmom interpretácia(formuly).
\newline

SAT je problém rozhodnutia, èi existuje interpretácia, ktorá spåòa danı booleovskı vıraz. Inımi slovami, pıtame sa, èi premenné daného booleovského vırazu, môu by nahradené hodnotami \(TRUE\) alebo \(FALSE\) takım spôsobom, e vıraz sa vyhodnotí ako \(TRUE.\) Ak je to tak, vıraz sa nazıva splnite¾nı. Na druhej strane, ak takéto priradenie neexistuje, vıraz je vyhodnotenı ako \(FALSE\) pre všetky moné priradenia premennıch, a vıraz je nesplnite¾nı. 

SAT problém je prvı známy NP-úplnı problém (dokázané Stephenom Cookom\cite{cook}). To znamená, e všetky problémy v triede zloitosti NP sú nanajvıš tak aké, ako SAT. Doposia¾, nie je známy algoritmus, ktorı efektívne rieši kadı SAT problém a všeobecne sa verí, e takıto algoritmus neexistuje.

\subsection{MRHS rovnice a sústavy}
V tejto podkapitole si zadefinujeme pojem rovnice s viacerımi pravımi stranami ako aj sústavu tıchto rovníc pod¾a èlánku \cite{mrhslingebra}. Všetky vıpoèty sú uskutoènené nad po¾om s dvoma prvkami (0 a 1) a oznaèením \(\mathbb{F} \). Všetky vektory \(\mathbb{F} \) sú riadkové vektory a sú oznaèené malım písmenom abecedy. Mnoiny sú znaèené ve¾kımi písmenami abecedy a matice tuènımi ve¾kımi písmenami. 

\begin{defn}
	\cite{mrhslingebra} Rovnicou s viacerımi pravımi stranami (MRHS) nad po¾om \(\mathbb{F} \) nazıvame vıraz tvaru
	\[x\mathbf{M} \in S,\]
	kde \(\mathbf{M}\) je matica s rozmermi \(n \times l\), kde n je poèet riadkov matice \(\mathbf{M}\) a l je poèet ståpcov, a \(S \subset    \mathbb{F}^l \) je mnoina \(l\)-bitovıch vektorov. Hovoríme, e \(x \in \mathbb{F}^n\) je riešením MRHS rovnice práve vtedy, keï \(x\mathbf{M} \in S\). 
\end{defn}

Sústavou rovníc s viacerımi pravımi stranami \(\mathcal{M}\) je mnoina \(m\) MRHS rovníc s rovnakou dimenziou \(n\) (rovnakı poèet riadkov). Formálne sa môe zapísa 
\[\mathcal{M} = \{x\mathbf{M}_i \in S_i|1\leq i\leq m \},\]
kde kadé \(\mathbf{M}_i\) je (\(n \times l_i\)) matica a \(S_i \subset \mathbb{F}^{l_i} \). Vektor \(x \in \mathbb{F}^n\) je riešením sústavy MRHS rovníc \(\mathcal{M}\), ak je tento vektor riešením pre všetky MRHS rovnice tejto sústavy.  

\textbf{Zdruená matica sústavy:} Sústave MRHS rovníc \(\mathcal{M} = \{x\mathbf{M}_i \in S_i\}\) môeme spoji všetky matice \(\mathbf{M_i}\), nako¾ko poèet ich riadkov je rovnakı. Vıslednú maticu oznaèujeme \(\mathbf{M}\) a nazıvame ju zdruenou maticou sústavy:
\[\mathbf{M} = [\mathbf{M_1}|\mathbf{M_2}|\cdots|\mathbf{M_m}]\]
Takisto budeme oznaèova mnoinu vektorov pravıch strán \(S_1 \times S_2 \times \cdots \times S_m\) ako \(S\). Nájdenie riešenia znamená nájdenie takého \(x \in \mathbb{F}^n\), pre ktoré platí \(x\mathbf{M} \in S\).\\
\textit{Pozn.:} Ståpce, ktoré patria \(\mathbf{M_i}\) nazıvame blok. V texte sa èasto budeme odvoláva na \(i\)-ty blok matice \(\mathbf{M}\).


\section{Algoritmy} \label{sec: algorithms}
V tejto kapitole si predstavíme všetky algoritmy, ktoré budeme vyuíva. Algoritmus na riešenie MRHS sústav, ktorı vyuíva MRHS solver je ukázanı v kapitole \ref{subsec: algMRHS}. Ostatné algoritmy sú algoritmy, ktoré sme implementovali do MRHS solvera a to prevod SAT problému na MRHS sústavu, heuristická optimalizácia poradia klauzúl v CNF formuli, Dual solver algoritmus na riešenie sústavy a transformácia MRHS sústavy na formát, ktorı vyaduje Dual solver algoritmus na vstupe.

\subsection{Algoritmus na riešenie MRHS sústavy} \label{subsec: algMRHS}
V tejto podkapitole si ukáeme algoritmus riešenia MRHS sústav, ktorı je implementovanı v MRHS solveri. Zápis tohoto algoritmu je prevzatı z \cite{jahobp} a \cite{mrhslingebra}


\begin{algorithm}[H]
	\caption{Uprav a vypoèítaj sústavu MRHS rovníc}
	\label{alg: solver} 
	\begin{algorithmic} 
		\REQUIRE MRHS sústava \(x\mathbf{M} \in S = S_1 \times S_2 \times \cdots \times S_m\)
		\ENSURE Mnoina \(X \subset \mathbb{F}^n\), pre ktorú platí  \(x\mathbf{M'} \in S\), \(\forall x \in X\), kde $\mathbf{M'}$ je upravená matica\\
		\COMMENT{ÚPRAVA ZDRUENEJ MATICE}
		\STATE Uprav maticu \(\mathbf{M}\) na redukovanı stupòovitı tvar cez riadkové úpravy.
		\STATE Vo všetkıch blokoch, ktoré obsahujú pivoty, vynuluj riadky, v ktorıch sa pivoty nachádzajú, cez såpcové úpravy.		
		\newline
		\COMMENT{REKURZÍVNE H¼ADANIE RIEŠENIA}
		\STATE \(X = \emptyset\), \(k = 1\), $x$ rozšírené o bity z $S_1[1]$
		\REQUIRE k, matica \(\mathbf{M}\), èiastoèné riešenie $x$, mnoina \(X\)
		\IF[m je poèet blokov]{k <= m}	 
		\FOR[n je poèet vektorov v mnoine  $S_k$]{j := 1, j<= n, j++}
		\IF{$x\mathbf{M_k}$ == $S_k[j]$}
		\IF{k == m}
		\STATE $X$ := $X$  \(\cup \{x\}\)
		\ENDIF
		\STATE rozšír $x$ o bity z $S_k[j]$
		\STATE $X$ := $X \cup rekurzia(k + 1, \mathbf{M}, x, X)$
		\ENDIF					
		\ENDFOR
		\ENDIF	
		\RETURN \(X\)
	\end{algorithmic}
\end{algorithm}

Tento algoritmus vráti len riešenia upravenej sústavy, a preto je nutné na základe vzorca \[x\mathbf{A^{-1}}\mathbf{A}\mathbf{M}\mathbf{B} \in S_M\mathbf{B},\] mono spätne vyjadri riešenie pôvodnej sústavy. Ak pre upravenú sústavu platí vzah $\mathbf{M'}=\mathbf{A}\mathbf{M}$, potom pre riešenia upravenej sústavy platí vzah $y=x\mathbf{A^{-1}}$. Keï osamostatníme $x$ dostaneme vzorec $x=y\mathbf{A}$, ktorım spätne vyrátame riešenia pôvodnej sústavy \cite{jahobp}. 
	
\subsection{Prevod SAT problému na MRHS} \label{subsubsec: satToMrhs}
 Kadá klauzula bude u nás predstavova jeden blok matice o ve¾kosti \(m \times n\), kde \(m\) je poèet literálov v klauzule a \(n\) je poèet všetkıch literálov. Poèet blokov hlavnej matice, je rovnı poètu klauzúl SAT problému. Prevod z formátu DIMACS na MRHS urobíme pomocou algoritmu v pseudokóde, ktorı je popísanı v algoritme \ref{alg: sat-to-mrhs-L}.

Pravé strany dostaneme tak, e si vypíšeme všetky moné riešenia pre danú klauzulu, ktorıch je \(2^{n}\), kde \(n\) oznaèuje poèet literálov v klauzule, a odstránime práve jedno riešenie, pre ktoré by klauzula nadobudla hodnotu \(FALSE\). Z toho dostávame e poèet pravıch strán je  \(2^{n}-1\).

\begin{algorithm}[H]
	\caption{Vytvorenie pravıch strán}
	\begin{algorithmic}
		\renewcommand{\algorithmicensure}{\textbf{Vıstup:}}
		\REQUIRE Matica \(\mathbf{S}\) \COMMENT{Matica \(\mathbf{S}\) z ALGORITMU \ref{alg: sat-to-mrhs-L}}
		\ENSURE Pole matíc \(\mathbb{P}\)
		\STATE Inicializuj \(\mathbb{P}\) a \(\mathbf{R}\)
		\FOR[s je velkos $\mathbf{S}$]{i := 0, i < s, i++}
		\STATE Vytvor pravdivostnú tabu¾ku pre N premennıch, kde N je ve¾kos \(\mathbf{S}[i]\) a ulo ju do \(\mathbf{R}\) \\
		\COMMENT{Vytvorenie zakázaného riešenia}
		\REQUIRE Pole \(K\) \COMMENT{\(K\) obsahuje \(i\)-ty riadok \(\mathbf{S}\)}
		\ENSURE Pole zakázané riešenie \(Z\)
		\STATE Inicializuj pole  \(Z\)
		\FOR[$m$ je ve¾kos $K$]{j := 0, j <  m, j++}
		\IF{\(K[j] > 0\)}
		\STATE Vlo hodnotu 0 do \(Z\)
		\ELSE
		\STATE Vlo hodnotu 1 do \(Z\)
		\ENDIF
		\ENDFOR
		\STATE Nájdi \(Z\) v \(\mathbf{R}\) a vyma ho. Vlo \(R\) do \(\mathbb{P}\)
		\ENDFOR
		\RETURN \(\mathbb{P}\)
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
	\caption{Vytvorenie hlavnej matice MRHS}
	\label{alg: sat-to-mrhs-L}
	\begin{algorithmic}
		\renewcommand{\algorithmicensure}{\textbf{Vıstup:}}
		\REQUIRE SAT problém vo formáte DIMACS 
		\ENSURE Matica \(\mathbf{S}\)
		\STATE Inicializuj premenné \(p\), \(k\),  \(count\), pole \(L\) a maticu  \(\mathbf{S}\)
		\STATE Naèítaj prvı riadok do \(L\)
		\WHILE{\(L[0]\) != \("p"\)}
		\STATE Naèítaj ïalší riadok
		\ENDWHILE
		\STATE Vyparsuj èíselné hodnoty z \(L\) a ulo ich do premennej \(p\) a \(k\) (poèet premenıch a poèet klauzúl).
		\WHILE{\(count\) == \(k\)}
		\STATE Inicializuj pole \(T\)
		\STATE Naèítaj riadok a ulo ho do \(T\)
		\STATE Vlo \(T\) do \(\mathbf{S}\)
		\STATE \(count++\) 
		\ENDWHILE
		\RETURN \(\mathbf{S}\)\\
		\COMMENT{Vytvorenie hlavnej matice}
		\REQUIRE Matica \(\mathbf{S}\), premenná \(p\)
		\ENSURE Pole matíc \(\mathbb{B}\) \COMMENT{Kadá matica reprezentuje jeden blok}
		\STATE Inicializuj pole matíc \(\mathbb{B}\)
		\STATE Inicializuj maticu \(\mathbf{H}\) a pole \(L\)
		\FOR[\(s\) je ve¾kos matice \(\mathbf{S}\) (poèet klauzúl)]{\(i := 0, i < s, i++\)}
		\FOR[\(p\) je poèet premennıch]{\(j := 0, j < p , j++\)}
		\FOR[\(r\) je ve¾kos \(\mathbf{S}{[i]}\) (poèet literálov v klauzule)]{\(k := 0, k < r, k++\)}
		\IF{\(\mathbf{S}[i][k]\) == \( j+1\) || \(\mathbf{S}[i][k]\) == \(-(j+1)\) }
		\STATE Vlo hodnotu 1 do \(L\)
		\ELSE
		\STATE Vlo hodnotu 0 do \(L\)
		\ENDIF
		\ENDFOR
		\STATE Vlo \(L\) do \(\mathbf{H}\) a vyèisti \(L\)
		\ENDFOR
		\STATE Vlo \(\mathbf{H}\) do \(\mathbb{B}\) a vyèisti \(\mathbf{H}\)
		\ENDFOR
		\RETURN \(\mathbb{B}\)
	\end{algorithmic}
\end{algorithm}

\subsection{Heuristická optimalizácia poradia klauzúl} \label{subsubsec: heuristicSAT}
V tejto kapitole si ukáeme heuristickı algoritmus na preusporiadanie klauzúl z práce \cite{fikobp}.


Majme bipartitnı graf \(G = (U, V, E)\) viï obrázok \ref{fig:Bipartitnı graf}:
\begin{figure}[H]
	\includegraphics[width=150px]{img/bipartite.png}
	\centering
	\caption{Bipartitnı graf \cite{bip}}
	\label{fig:Bipartitnı graf}
\end{figure}
kde \(|U|= n\) sú premenné, \(|V| = m\) sú klauzuly, \(E\) obsahuje hranu \((v_i, u_j)\), ak v \(i\)-tej klauzule \(i\) vystupuje \(j\)-ta premenná.\\
\\
Uvaujme, e klauzuly sú v nejakom poradí \(P\), èomu zodpovedajú èíslované vrcholy \({v_1, v_2, ..., v_m}\). Uvaujme postupnos indukovanıch podgrafov \((U^i, V^i, E^i)\), kde \(V^i = {v_1, v_2, ..., v_i}\), a \(U^i, E^i\), obsahujú všetky vrcholy a príslušné hrany spojené s \(V^i\).

Definujme postupnos \(d\), kde \(d_0 = 0\) a \(d_i = |U^i| - |U^{i-1}|\) (èie poèet vrcholov \(|U|\) pridanıch do podgrafu, ak pridáme \(v_i\)).\\

Úlohou je nájdenie poradia \(P\) vrcholov z \(V\) také, e postupnos \(d\) je minimálna v
lexikografickom poradí (t.j. \(d^P <= d^R\) ak existuje \(k\) také, e \(d^P_k <= d^R_k\) a pre všetky \(i < k: d^P_i = d^R_i\)).

Klauzuly v algoritme è. \ref{alg: heuristic-sat} sú reprezentované ako matica, kde kadı riadok matice reprezentuje jednu klauzulu. Na prvom indexe kadého riadku, je èíslo klauzuly a potom nasledujú premenné, ktoré obsahuje, ale iba v kladnej forme.

Premenné sú reprezentované tie v matici, kde kadı riadok matice reprezentuje jednu premennú. Na prvom indexe kadého riadku, je èíslo premennej a potom nasledujú èísla klauzúl, s ktorımi je daná premenná spojená.
\begin{algorithm}[H]
	\caption{Heuristická optimalizácia poradia klauzúl}
	\label{alg: heuristic-sat}
	\begin{algorithmic}
		\renewcommand{\algorithmicensure}{\textbf{Vıstup:}}
		\REQUIRE Matica \(\mathbf{S}\) \COMMENT{Matica \(\mathbf{S}\) z ALGORITMU \ref{alg: sat-to-mrhs-L}}
		\ENSURE Pole \(P\)
		\STATE Inicializuj maticu \(\mathbf{V}\)  a  \(\mathbf{U}\) 
		\FOR[s je ve¾kos $\mathbf{S}$]{i := 0, i < s, i++}
		\STATE Zoraï \(\mathbf{V}\) od najmenšieho stupòa
		\STATE Zoraï \(\mathbf{U}\) od najväèšieho stupòa
		\STATE Inicializuj \(MIN\) (klauzuly s minimálnym stupòom) a \(MAX\) (premenné s maximálnym stupòom)
		\STATE Nájdi všetky klauzuly v \(\mathbf{V}\) s minimálnym stupòom a vlo ich hodnotu na indexe 0 do \(MIN\)
		\IF[$m$ je ve¾kos $MIN$]{\(m\)  == 1}
		\STATE Vlo \(MIN\)[0] do \(P\)
		\ELSE
		\STATE Nájdi všetky premenné z \(\mathbf{U}\) s maximálnym stupòom, ktoré sú spojené s nejakou klauzulou z \(\mathbf{V}\) a vlo ich hodnotu na indexe 0 do \(MAX\)
		\IF[$n$ je ve¾kos $MAX$]{n == 1}
		\STATE Vlo hodnotu na indexe 0 z klauzule z \(V\) ktorá je spojená s premennou z \(\mathbf{U}\) do \(P\)
		\ELSE
		\STATE Vyber náhodne jeden index z \(MAX\) a vlo index klauzule, ktorá je spojená s touto premennou do po¾a \(P\)
		\ENDIF
		\ENDIF
		\STATE Odstráò vybranú klauzulu z \(\mathbf{V}\) a všetky premenné z \(\mathbf{U}\) s òou spojené.
		\ENDFOR
		\RETURN \(P\)
	\end{algorithmic}
\end{algorithm}

Úlohou algoritmu je vysklada novú sústavu, takım spôsobom, e kadá pridaná klauzula do sústavy pridá èo najmenej novıch premennıch. Inak povedané, sú preferované klauzuly, ktoré sa vyskytujú v najviac klauzulách CNF formuly.

\newpage
\subsection{Transformácia pre Dual space solver} \label{subsec: mrhstodual}
V tejto kapitole si ukáeme algoritmus transformácie MRHS sústavy pre algoritmus Dual solver. 

Ako prvé je potrebné vyrobi kontrolnú maticu  \(\mathbf{H}\) ku matici  \(\mathbf{M}\). Matica  \(\mathbf{M}\) má rozmery \(n \times l\), kde n je poèet riadkov matice a l je poèet ståpcov. Po upravení matice \(\mathbf{M}\) na redukovanı stupòovitı tvar, zoberieme \(n - l\) poslednıch såpcov a pridáme na spodnú èas matice maticu identity o ve¾kosti \(n \times n\). Tımto dostaneme kontrolnú maticu \(\mathbf{H}\), pre ktorú platí \(\mathbf{M}\mathbf{H} = 0 \). 

Ako druhé vytvoríme maticu \(\mathbf{S}\), ktorú vyrobíme nasledovne: 
\[
\mathbf{S} = 
\left(
\begin{array}{cccc}
S_1 & 0 & \dots & 0 \\
0 & S_2 & \dots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 01 & \dots & S_m  
\end{array}
\right)
\]
Matica  \(\mathbf{S}\) je blokovo diagonálna matica vytvorená z mnoín pravıch strán sústavy. Pre správnu pravú stranu \(s\) musí plati \(x\mathbf{M} = s\) a teda musí plati aj \(s \cdot \mathbf{H}^T = 0\). Vıstupom algoritmu bude matica \(\mathbf{V}\), pre ktorú platí \(\mathbf{V} = \mathbf{S} \cdot \mathbf{H}^T\) \cite{dualspacesolver}. Táto matica bude vstupom pre Dual solver algoritmus.

Nišie je spísanı pseudokód pre tento algoritmus.

\begin{algorithm}[H]
	\caption{Vytvorenie Dual solver vstupnej matice}
	\label{alg: mrhsdtodualsolver} 
	\begin{algorithmic} 
		\REQUIRE MRHS sústava \(x\mathbf{M} \in S = S_1 \times S_2 \times \cdots \times S_m\)
		\ENSURE Matica \(\mathbf{V}\)\\
		\STATE Uprav maticu \(\mathbf{M}\) na redukovanı stupòovitı tvar.
		\STATE Zober \(n - l\) poslednıch såpcov a pridaj k nim maticu identity o ve¾kosti \(n \times n\). Vıslednú maticu oznaèíme \(\mathbf{H}\)
		\STATE 	Vytvor blokovo diagonálnu maticu  \(\mathbf{S}\) z mnoiny pravıch strán sústavy.
		\STATE Vytvor maticu \(\mathbf{V}\), pre ktorú platí \(\mathbf{V} = \mathbf{S} \cdot \mathbf{H}^T\)
		\RETURN \(\mathbf{V}\)
	\end{algorithmic}
\end{algorithm}

\subsection{Dual space solution algoritmus} \label{subsec: dualspacesolutionalgorithm}
Dual space solution algoritmus, narozdiel od pôvodného algoritmu \ref{alg: solver} riešenia MRHS sústavy nie je závislı od poriadia rovníc vrámci sústavy. Princíp algoritmu je zaloenı na subset sum probléme \cite{subsetsum}, na nájdení urèitého súètu v danej mnoine. V našom prípade pôjde o nájdení súètu 0 v rámci ståpcu matice \(\mathbf{V}\). Z toho vyplıva predpoklad, e tento algoritmus bude silno závislı na hustote 1 v matici  \(\mathbf{V}\) a poradí ståpcov. Poradie ståpcov môe by zmenené pomocou lineárnej algebri na ståpcoch bez zmeny pôvodného riešenia MRHS sústavy.

Bliší popis algoritmu spolu s pseudokódom môete nájs v èlánku \cite{dualspacesolver}, ktorı vznikol ako produkt tohoto tímového projektu. Vısledky experimentov dual space solution algoritmu nájdete v kapitole o experimentoch. 

\section{Dokumentácia k programu}
V tejto kapitole si zhrnieme funkcionalitu, ktorá bola pridaná do MRHS solvera na základe SAT challenge špecifikácie a algoritmov.

\subsection{SAT challenge špecifikácia}
V tejto kapitole je struène popísaná SAT challenge špecifikácia. Zdroj: \cite{satcomp}. Nako¾ko tento tímovı projekt je viac zameranı na vedeckú èinnos, zo SAT challenge špecifikácie sme si privlastnili len input a output formáty, ktoré ma náš program spåòa. 

\subsubsection{DIMACS input formát} \label{subsubsec: DIMACS}
DIMACS CNF formát, je štandardnı vstupnı formát pre SAT solvery. Súbor DIMACS zaèína komentármi, ktoré sú na zaèiatku oznaèené malım písmenom c. Prvı riadok po komentári, je v tvare \(p\) \(cnf\) \(i\) \(j\). Premená \(i\) oznaèuje presnı poèet premennıch a \(j\) presnı poèet klauzúl obsiahnutıch v súbore, potom nasledujú klauzuly. Kadá klauzula môe obsahova nenulové èíslo z rozpätia \(-i\) a po \(i\). Záporné èísla oznaèujú negáciu. Kadı riadok, v ktorom je zapísaná klauzula, je ukonèenı nulou. Jeden riadok nemôe obsahova navzájom opaèné literály. Riadok, ktorı zaèína písmenom \(x\), oznaèuje klauzulu v \(XOR\) tvare.

\begin{figure}[H]
	\centering
	\begin{BVerbatim}
	c Súbor zaèína komentármi
	p cnf 5 3
	1 -5 4 0
	-1 5 3 4 0
	x 3 4 0
	\end{BVerbatim}
	\caption{Príklad DIMACS vstupného súboru.}
\end{figure}

V logickom tvare by vyzerala formula z obrázka è. 3 následovne:

\[
(x{_1} \vee \neg x{_5} \vee x{_4}) \wedge (\neg x{_1} \vee x{_5} \vee x{_3} \vee x{_4}) \wedge (\neg x{_3} \vee \neg x{_4}) \wedge (x{_3} \vee x{_4})
\]

\subsubsection{Output formát}
Do vıstupu programu boli pridané vypísi splnite¾nosti vstupnej k-SAT klauzule. V nišie zobrazenej tabu¾ke sú zapísané exit kódy programu spolu s vypísom splnite¾nosti, ktorı predstavujú. 

\begin{table}[H]
	\centering
	\caption{Exit kódy}
	\begin{tabular}{|l|l|}
		\hline
		exit(kód) & SAT ?         \\ \hline
		exit(10)  & SATISFIABLE   \\ \hline
		exit(20)  & UNSATISFIABLE \\ \hline
		exit(0)   & UNKNOWN       \\ \hline
	\end{tabular}
\end{table} 

\subsection{MRHS solver} \label{sec: solver}
Na riešenie sústav s viacerımi pravımi stranami budeme pouíva program MRHS solver, ktorı vyvinul prof. Ing. Pavol Zajac, phD. Algoritmus \ref{alg: solver}, ktorı sme si predstavili v kapitole \ref{sec: algorithms} sa vyuíva práve v tomto programe na riešenie sústavy. 


Jednım z naších cielov bolo implementova aby vstupom algoritmu bol súbor formátu DIMACS ukázanı v kapitole \ref{subsubsec: DIMACS}. Následne aby sme mohli vyuíva optimalizaènı algoritmus z kapitoly \ref{subsubsec: heuristicSAT}, museli sme rozšíri MRHS solver o nové interface-i aby vedel pracova s CNF štruktúrami. Nako¾ko pôvodnı algoritmus \ref{alg: solver} riešenia sústavy stále pracuje so štruktúrami podobnımi s tımi spomenutımi v nasledujúcej kapitole o vstupnom formáte súborov pre MRHS solver, bolo nutné implementova algoritmus z kapitoly \ref{subsubsec: satToMrhs} aby sme k-SAT problém transformovali do MRHS sústavy. Následne takto transformovanı k-SAT problém je moné rieši MRHS solverom. 

V prípade, e máme MRHS sústavu v takto pôvodnom tvare, je moné pomocou algoritmu \ref{alg: mrhsdtodualsolver} transformova sústavu do matice \(\mathbf{V}\), ktorú vie vypoèíta algoritmus Dual space solver spomenutı v kapitole \ref{subsec: dualspacesolutionalgorithm} a podrobnejšie spísanı v èlánku  \cite{dualspacesolver}.

\subsubsection{Vstupnı formát pre MRHS solver}
Pôvodnı vstupnı súbor obsahuje MRHS sústavu zapísanú v nasledovnom formáte: 
\begin{itemize}
	\item konfiguraènı riadok v tvare \(n\ m\ k_1\ l_1\ k_2\ l_2\ \cdots\ k_m\ l_m\), kde \(n\) je poèet premennıch, \(m\) poèet blokov sústavy, \(k_i\) je poèet ståpcov \(i\)-teho bloku, \(l_i\) je poèet pravıch strán \(i\)-teho bloku,
	\item \(n\) riadkov zaèínajúcich a konèiacich hranatımi zátvorkami, obsahujúcich \(\sum_{i=1}^{m} k_i\) bitov,
	\item \(\sum_{i=1}^{m} l_i\) riadkov zaèínajúcich a konèiacich hranatımi zátvorkami, obsahujúcich \(k_i\) bitov.
\end{itemize}

Na nišie zobrazenom obrázku è. \ref{fig: inputMRHSexample} je ukázanı príklad vstupného súboru pre MRHS solver. Sústava obsahuje 3 premenné, 2 rovnice, kde prvá rovnica obsahuje 7 pravıch strán a 3 ståpce a druhá rovnica obsahuje 2 pravé strany a 2 ståpce.

V algebraickom zápise, MRHS sústava z obrázka è. \ref{fig: inputMRHSexample} vyzerá následovne: 

MATICA
\[
\mathbf{M} = 
\left[
\begin{array}{ccc|ccc}
1 & 0 & 0 & 1 & 0  \\
0 & 1 & 0 & 0 & 1  \\
0 & 0 & 1 & 0 & 0  
\end{array}
\right]
\]


PRAVÉ STRANY
\[
S = 
\left\{
\begin{array}{ccc}
(0, 0, 1);\\
(0, 1, 0);\\
(0, 1, 1);\\
(1, 0, 1);\\
(1, 1, 0);\\
(1, 0, 0);\\
(1, 1, 1);
\end{array}
\right\}
\times
\left\{
\begin{array}{cc}
(0, 0);\\
(0, 1);\\
(1, 0);
\end{array}
\right\}
\]

\begin{figure}[H]
	\centering
	\begin{BVerbatim}
	3 2 3 7 2 3
	[100 10]
	[010 01]
	[001 00]
	
	[001]
	[010]
	[011]
	[101]
	[110]
	[100]
	[111]
	
	[00]
	[01]
	[10]
	\end{BVerbatim}
	\caption{Príklad MRHS vstupného súboru.}
	\label{fig: inputMRHSexample}
\end{figure}

\subsection{Nová funkcionalita}
Nako¾ko MRHS solver je konzolová aplikácia, ktorej úèelom je vypoèíta sústavu rovníc s viacerımi pravımi stranami, tak celı beh programu je nastavenı pri spustení programu pomocou prepínaèov. Do programu boli pridané nasledovné prepínaèe: 

\begin{itemize}
	\item -t  = poèet sekúnd, po ktorıch sa má program vypnú a vráti exit kód UNKNOWN (0)
	\item -i = s hodnotou 1 zapne optimalizáciu vstupnej k-SAT formule (algoritmus \ref{alg: heuristic-sat}), defaultne je zadaná hodnota nula (bez optimalizácie)
	\item -a = typ solvera. Pre hodnotu 0 je algoritmus riešenia sústavy nastavenı na pôvodnı algoritmus riešenia (alg. \ref{alg: solver}). Pre hodnotu 2 je pouitı dual space solution algoritmus (alg. \ref{subsec: dualspacesolutionalgorithm}). Pre hodnotu 3 sa sústava vypoèíta oboma algoritmami.
\end{itemize}

Prepínaèe programu sú stavané na jednoduchú prácu so solverom poèas experimentov. O metodike experimentov viac v kapitole \ref{subsec: metodikaEXP}
\section{Experimentálna èas}
Naším cie¾om bolo systematicky porovna dobu riešenia náhodne generovanej sústavy k-SAT klauzule s dobou riešenia tejto sústavy po úprave algoritmom \ref{alg: heuristic-sat}. Na riešenie sústav sme pouili MRHS solver s algoritmami na riešenie sústavy \ref{alg: solver} a dual space solution z kapitoly \ref{subsec: dualspacesolutionalgorithm}. Na generovanie k-SAT formúl sme vyuili program Cnfgen \cite{cnfgen}. 

\subsection{Testovacia platforma}
Všetky vıpoèty boli robené na jednom zariadení pre zaistenie èo najmenších odchılok. Parametre poèítaèa, na ktorom boli uskutoènené vıpoèty, sú:
\begin{itemize}
	\item Procesor: Intel core i5 - 8600K, 3.6GHz
	\item RAM: 16GB
\end{itemize} 
 Vıpoèty prebiehali na jednom jadre procesora.
 
 
 \subsection{Metodika experimentov}
Skúmali sme náhodné k-Sat problémy. Pre tieto testy sme si zvolili \(k = {3, 4}\) a menili sme rôzne faktory a sledovali ako vplıvajú na vıstup. Sledovanou premennou bude èas [s], za ktorı dokáu algoritmy na riešenie sústav nájs všetky riešenia problému. Pre kadú sadu testov, sa vygenerovali problémy s následovnımi faktormi:

\textbf{Fixnı pomer \(m/n\)}

Tento pomer, sme volili rôzny pre jednotlivé \(k\) pod¾a štúdií \cite{Threshold}\cite{Threshold2}, tak aby sme boli v oblasti tzv. najaších problémov. 

\textbf{Pevne dané \(n\) a premenlivé \(m\)}

Pri tomto teste sme si nastavili spodnú hranicu tak, aby bola pravdepodobnos splnite¾nosti cca. 90\% a hornú hranicu sme nastavili tak, aby bola pravdepodobnos splnite¾nosti 0\% pod¾a vzahu \(m/n = 2^{k} \log 2 - \frac{\log 2}{2}\) (vzah prebratı z \cite{unsatisfiable}). 
\\
Následne sme na tieto problémy aplikovali naše algoritmy samostatne, ale aj v kombinácii. Aplikovali sa naslednovné algoritmy:

\textbf{Experimenty s pôvodnım algoritmom riešenia sústavy}

Vygenerované k-SAT problémy boli transformované na MRHS sústavu a následne riešené algoritmom \ref{alg: solver}.

\textbf{Experimenty s dual space solution algoritmom}
Vygenerované k-SAT problémy po transformácií na MRHS sústavu boli transformované na novú reprezentáciu problému spomenutú v kapitole \ref{subsec: mrhstodual} a následne riešenie pomocou algoritmu z kapitoly \ref{subsec: dualspacesolutionalgorithm}.

\textbf{Experimenty s heuristickou optimalizáciou}
Na vygenerované k-sat problémy, sme aplikovali nami implementovanú heuristickú optimalizáciu poradia klauzúl. Následne sme porovnávali èasy, potrebné na nájdenie všetkıch riešení s vyuitím pôvodného algoritmu riešenia sústavy a dual space solution algoritmom.


\subsection{Vyhodnotenie experimentov}

\subsubsection{3-SAT pevnı pomer \(m/n\)}
V tomto experimente sme skúmali vplyv zvyšujúceho sa poètu premennıch \(n\) v 3-sat formule pri pomere  \(m/n = 4.2\). 

\begin{figure}[H]
	\includegraphics[width=\textwidth]{img/3satPevnyPomer.png}
	\centering
	\caption{Experiment 1: 3-SAT pevnı pomer \(m/n\)}
	\label{exp: 3-sat-fixed}
\end{figure}

Z vyššie zobrazeného obrázku \ref{exp: 3-sat-fixed} mono vidie, e dual space solution algoritmus bez pre-optimalizácie exponenciálne rıchlejšie rastie v porovnaní s ostatnımi spôsobmi riešenia. Najlepší èas sme dosiahli v prípade pouitia pôvodného algoritmu a pre-optimalizácie 3-sat formule.

\subsubsection{3-SAT premenlivı pomer}
V tomto experimente sme skúmali vplyv zvyšujúceho sa pomeru \(m/n\) na dobu riešenia sústavy.

\begin{figure}[H]
\includegraphics[width=\textwidth]{img/3satPremenlivyPomer.png}
\centering
\caption{Experiment 2: 3-SAT premenlivı pomer}
\label{exp: 3-sat-variable}
\end{figure}

\subsubsection{4-SAT pevnı pomer \(m/n\)}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{img/4satPevnyPomer.png}
	\centering
	\caption{Experiment 3: 4-SAT pevnı pomer \(m/n\)}
	\label{exp: 4-sat-fixed}
\end{figure}


\subsubsection{4-SAT premenlivı pomer}

\begin{figure}[H]
	\includegraphics[width=\textwidth]{img/4satPremenlivyPomer.png}
	\centering
	\caption{Experiment 4: 4-SAT premenlivı pomer}
	\label{exp: 4-sat-variable}
\end{figure}